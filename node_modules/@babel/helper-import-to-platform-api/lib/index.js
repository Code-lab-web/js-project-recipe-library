"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildParallelStaticImports = buildParallelStaticImports;
exports.importToPlatformApi = importToPlatformApi;
var _core = require("@babel/core");
var _helperModuleImports = require("@babel/helper-module-imports");
var _platformsSupport = require("./platforms-support.js");
function imp(path, name, module) {
  return (0, _helperModuleImports.addNamed)(path, name, module, {
    importedType: "es6"
  });
}
const imr = s => _core.template.expression.ast`
  import.meta.resolve(${s})
`;
const imrWithFallback = s => _core.template.expression.ast`
  import.meta.resolve?.(${s}) ?? new URL(${_core.types.cloneNode(s)}, import.meta.url)
`;
function importToPlatformApi(targets, transformers, toCommonJS) {
  const {
    needsNodeSupport,
    needsWebSupport,
    nodeSupportsIMR,
    webSupportsIMR,
    nodeSupportsFsPromises
  } = (0, _platformsSupport.default)(targets);
  const supportIsomorphicCJS = transformers.commonJS != null;
  let buildFetchAsync;
  let buildFetchSync;
  const p = ({
    web: w = needsWebSupport,
    node: n = needsNodeSupport,
    nodeFSP: nF = nodeSupportsFsPromises,
    webIMR: wI = webSupportsIMR,
    nodeIMR: nI = nodeSupportsIMR,
    toCJS: c = toCommonJS,
    supportIsomorphicCJS: iC = supportIsomorphicCJS
  }) => +w + (+n << 1) + (+wI << 2) + (+nI << 3) + (+c << 4) + (+nF << 5) + (+iC << 6);
  const readFileP = (fs, arg) => {
    if (nodeSupportsFsPromises) {
      return _core.template.expression.ast`${fs}.promises.readFile(${arg})`;
    }
    return _core.template.expression.ast`
      new Promise(
        (a =>
          (r, j) => ${fs}.readFile(a, (e, d) => e ? j(e) : r(d))
        )(${arg})
      )`;
  };
  switch (p({
    web: needsWebSupport,
    node: needsNodeSupport,
    webIMR: webSupportsIMR,
    nodeIMR: nodeSupportsIMR,
    toCJS: toCommonJS
  })) {
    case p({
      toCJS: true,
      supportIsomorphicCJS: true
    }):
      buildFetchSync = specifier => transformers.commonJS(_core.types.identifier("require"), specifier);
      break;
    case p({
      web: true,
      node: true
    }):
      buildFetchAsync = specifier => {
        const web = transformers.webFetch(_core.types.callExpression(_core.types.identifier("fetch"), [(webSupportsIMR ? imr : imrWithFallback)(_core.types.cloneNode(specifier))]));
        const node = supportIsomorphicCJS ? _core.template.expression.ast`
              import("module").then(module => ${transformers.commonJS(_core.template.expression.ast`module.createRequire(import.meta.url)`, specifier)})
            ` : nodeSupportsIMR ? _core.template.expression.ast`
                import("fs").then(
                  fs => ${readFileP(_core.types.identifier("fs"), _core.template.expression.ast`new URL(${imr(specifier)})`)}
                ).then(${transformers.nodeFsAsync()})
              ` : _core.template.expression.ast`
                Promise.all([import("fs"), import("module")])
                  .then(([fs, module]) =>
                    ${readFileP(_core.types.identifier("fs"), _core.template.expression.ast`
                        module.createRequire(import.meta.url).resolve(${specifier})
                      `)}
                  )
                  .then(${transformers.nodeFsAsync()})
              `;
        return _core.template.expression.ast`
            typeof process === "object" && process.versions?.node
              ? ${node}
              : ${web}
          `;
      };
      break;
    case p({
      web: true,
      node: false,
      webIMR: true
    }):
      buildFetchAsync = specifier => transformers.webFetch(_core.types.callExpression(_core.types.identifier("fetch"), [imr(specifier)]));
      break;
    case p({
      web: true,
      node: false,
      webIMR: false
    }):
      buildFetchAsync = specifier => transformers.webFetch(_core.types.callExpression(_core.types.identifier("fetch"), [imrWithFallback(specifier)]));
      break;
    case p({
      web: false,
      node: true,
      toCJS: true
    }):
      buildFetchSync = specifier => transformers.nodeFsSync(_core.template.expression.ast`
            require("fs").readFileSync(require.resolve(${specifier}))
          `);
      buildFetchAsync = specifier => _core.template.expression.ast`
            require("fs").promises.readFile(require.resolve(${specifier}))
              .then(${transformers.nodeFsAsync()})
          `;
      break;
    case p({
      web: false,
      node: true,
      toCJS: false,
      supportIsomorphicCJS: true
    }):
      buildFetchSync = (specifier, path) => transformers.commonJS(_core.template.expression.ast`
            ${imp(path, "createRequire", "module")}(import.meta.url)
          `, specifier);
      break;
    case p({
      web: false,
      node: true,
      toCJS: false,
      nodeIMR: true
    }):
      buildFetchSync = (specifier, path) => transformers.nodeFsSync(_core.template.expression.ast`
            ${imp(path, "readFileSync", "fs")}(
              new URL(${imr(specifier)})
            )
          `);
      buildFetchAsync = (specifier, path) => _core.template.expression.ast`
          ${imp(path, "promises", "fs")}
            .readFile(new URL(${imr(specifier)}))
            .then(${transformers.nodeFsAsync()})
        `;
      break;
    case p({
      web: false,
      node: true,
      toCJS: false,
      nodeIMR: false
    }):
      buildFetchSync = (specifier, path) => transformers.nodeFsSync(_core.template.expression.ast`
            ${imp(path, "readFileSync", "fs")}(
              ${imp(path, "createRequire", "module")}(import.meta.url)
                .resolve(${specifier})
            )
          `);
      buildFetchAsync = (specifier, path) => transformers.webFetch(_core.template.expression.ast`
            ${imp(path, "promises", "fs")}
              .readFile(
                ${imp(path, "createRequire", "module")}(import.meta.url)
                  .resolve(${specifier})
              )
          `);
      break;
    default:
      throw new Error("Internal Babel error: unreachable code.");
  }
  buildFetchAsync != null ? buildFetchAsync : buildFetchAsync = buildFetchSync;
  const buildFetchAsyncWrapped = (expression, path) => {
    if (_core.types.isStringLiteral(expression)) {
      return _core.template.expression.ast`
        Promise.resolve().then(() => ${buildFetchAsync(expression, path)})
      `;
    } else {
      return _core.template.expression.ast`
        Promise.resolve(\`\${${expression}}\`).then((s) => ${buildFetchAsync(_core.types.identifier("s"), path)})
      `;
    }
  };
  let buildFetch = buildFetchSync;
  if (!buildFetchSync) {
    if (toCommonJS) {
      buildFetch = (specifier, path) => {
        throw path.buildCodeFrameError("Cannot compile to CommonJS, since it would require top-level await.");
      };
    } else {
      buildFetch = buildFetchAsync;
    }
  }
  return {
    buildFetch,
    buildFetchAsync: buildFetchAsyncWrapped,
    needsAwait: !buildFetchSync
  };
}
function buildParallelStaticImports(data, needsAwait) {
  if (data.length === 0) return null;
  const declarators = [];
  if (data.length === 1) {
    let rhs = data[0].fetch;
    if (needsAwait) rhs = _core.types.awaitExpression(rhs);
    declarators.push(_core.types.variableDeclarator(data[0].id, rhs));
  } else if (needsAwait) {
    const ids = data.map(({
      id
    }) => id);
    const fetches = data.map(({
      fetch
    }) => fetch);
    declarators.push(_core.types.variableDeclarator(_core.types.arrayPattern(ids), _core.types.awaitExpression(_core.template.expression.ast`
            Promise.all(${_core.types.arrayExpression(fetches)})
          `)));
  } else {
    for (const {
      id,
      fetch
    } of data) {
      declarators.push(_core.types.variableDeclarator(id, fetch));
    }
  }
  return _core.types.variableDeclaration("const", declarators);
}

//# sourceMappingURL=index.js.map
