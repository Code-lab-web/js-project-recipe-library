"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _pluginSyntaxImportAttributes = require("@babel/plugin-syntax-import-attributes");
var _helperImportToPlatformApi = require("@babel/helper-import-to-platform-api");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  const {
    types: t,
    template
  } = api;
  api.assertVersion("^7.22.0 || >8.0.0-alpha <8.0.0-beta");
  const targets = api.targets();
  let helperESM;
  let helperCJS;
  const transformers = {
    commonJS: options.uncheckedRequire ? (require, specifier) => t.callExpression(require, [specifier]) : null,
    webFetch: fetch => template.expression.ast`${fetch}.then(r => r.json())`,
    nodeFsSync: read => template.expression.ast`JSON.parse(${read})`,
    nodeFsAsync: () => template.expression.ast`JSON.parse`
  };
  const getHelper = file => {
    const modules = file.get("@babel/plugin-transform-modules-*");
    if (modules === "commonjs") {
      return helperCJS != null ? helperCJS : helperCJS = (0, _helperImportToPlatformApi.importToPlatformApi)(targets, transformers, true);
    }
    if (modules == null) {
      return helperESM != null ? helperESM : helperESM = (0, _helperImportToPlatformApi.importToPlatformApi)(targets, transformers, false);
    }
    throw new Error(`@babel/plugin-transform-json-modules can only be used when not ` + `compiling modules, or when compiling them to CommonJS.`);
  };
  function getAttributeKey({
    key
  }) {
    return t.isIdentifier(key) ? key.name : key.value;
  }
  function hasTypeJson(attributes) {
    return !!(attributes != null && attributes.some(attr => getAttributeKey(attr) === "type" && attr.value.value === "json"));
  }
  return {
    name: "transform-json-modules",
    inherits: _pluginSyntaxImportAttributes.default,
    visitor: {
      Program(path) {
        if (path.node.sourceType !== "module") return;
        const helper = getHelper(this.file);
        const data = [];
        for (const decl of path.get("body")) {
          if (!decl.isImportDeclaration()) continue;
          const attributes = decl.node.attributes || decl.node.assertions;
          if (!hasTypeJson(attributes)) continue;
          if (decl.node.phase != null) {
            throw decl.buildCodeFrameError("JSON modules do not support phase modifiers.");
          }
          if (attributes.length > 1) {
            const paths = decl.node.attributes ? decl.get("attributes") : decl.get("assertions");
            const index = getAttributeKey(attributes[0]) === "type" ? 1 : 0;
            throw paths[index].buildCodeFrameError("Unknown attribute for JSON modules.");
          }
          let id;
          let needsNS = false;
          for (const specifier of decl.get("specifiers")) {
            if (specifier.isImportSpecifier()) {
              throw specifier.buildCodeFrameError("JSON modules do not support named imports.");
            }
            id = specifier.node.local;
            needsNS = specifier.isImportNamespaceSpecifier();
          }
          id != null ? id : id = path.scope.generateUidIdentifier("_");
          let fetch = helper.buildFetch(decl.node.source, path);
          if (needsNS) {
            if (helper.needsAwait) {
              fetch = template.expression.ast`
                ${fetch}.then(j => ({ default: j }))
              `;
            } else {
              fetch = template.expression.ast`{ default: ${fetch} }`;
            }
          }
          data.push({
            id,
            fetch
          });
          decl.remove();
        }
        if (data.length === 0) return;
        const decl = (0, _helperImportToPlatformApi.buildParallelStaticImports)(data, helper.needsAwait);
        if (decl) path.unshiftContainer("body", decl);
      }
    }
  };
});

//# sourceMappingURL=index.js.map
